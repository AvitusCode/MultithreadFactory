# MultithreadFactory

Код main получает аргументы командной строки (файл с конфигами)
Конфиги оформляются в соответствии с правилами грамматики

// Устанавливает файл входного потока
INPUT = ... .txt 

// Устанавливаем выходной поток
OUTPUT = ... .txt 

// Устанавливаем класс ридера, через точку-запятую его конфиг.
READER_AND_CFG = Reader; ... .txt

WRITER_AND_CFG = Writer; ... .txt // Аналогично с writer

// Конвейер изначально не знает, какие именно поступают классы в качестве работы. Для реализации интроспекции
необходимо писать имя класса, а также конфиг файл через точку-запятую.
EXECUTOR_NAME_AND_CFG = LookUpTable; ... .txt; LookUpTable; ... .txt

// В конце можно установить порядок следования рабочих на конвейере.
ARRAY_OF_EXECUTOR_POS = 1; 2

// Устанавливаем максимальное количество потоков
MAX_THREADS = {number}

У каждого работника также имеется конфиг со своей уникальной грамматикой. Основные поля - это MAX_NOTIFY and MAX_THREADS Все входные данные проходят синтаксическую исемантическую проверку, прежде чем установить работника на конвейер.

Главный код менеджера конструирует весь конвейер, устанавливает конфиги, открывает входной и выходной поток, а также
выполняет минимальную проверку данных. После чего конвейер запускается посредством метода run(). 
В момент установки рабочих, каждый из них начинает "знакомиться" друг с другом. Происходит обмен типами данных, которые работник может обработать, переслать далее по конвейеру. Происходит обмен внутренними классами, реализующими интерфейс Inotify - для оповещения о готовности файла,
IMediator - для передачи данных. 
Работа завершается при отправке команды Null всем потокам читателя. Далее происходит постепенное закрытие потоков и выход из программы.

## Краткое описание реализации многопоточности.
У Консьюмеров имеется свой класс INotify, имплементирующий соответствующий интерфейс с единственным методом:
RC notify(int idChunk, int numNotification)

* idChunk - номер куска, который готов для передачи
* numNotification - номер уведомления консюмера о готовности этого куска

Если консьюмер уже забрал этот кусок (очевидно, это не первое уведомление: numNotification > MAX_NOTOFOCATIONS), то он игнорирует это уведомление , вернув код возврата _WARNING_CHUNK_ALRADY_TAKEN_.
В противном случае код  notify должен записать в какой-то приватный контейнер номер этого очередного уведомления.
Когда поток, в котором исполняется метод execute() консьюмера, будет готов обработать очередной кусок своего провайдера, он дернет код посредника, предоставленного провайдером, и заберет очередную порцию для обработки. Посредник, завершая операцию передачи данных, должен отметить в контейнере своего провайдера, что этому конкретному консьмеру очередной кусок передали и уведомлять его об этом куске уже не нужно.
ВОПРОС: Зачем так много возни? Дело в том, что Ахиллесова пята реализаций многопоточных режимов - это гонка за данными, когда код из разных потоков (потоки, в которых исполняется код run() каждого из участников конвейера) предпринимает попытку писать в чью-то общедоступную структуру данных (общедоступную не в смысле public, а в смысле возможности изменить ее содержимое непосредственно или косвенно, через колбека). Вот чтобы устранить саму возможность появления гонок за данными, и предлагается так много вспомогательных счетчиков и полей. Для интереса было решено не использовать стандартные механизмы синхронизации из коробки Java.


## Иллюстрация однопоточного режима. 
В многопоточном режиме имеем "ромб", сиречь рабочие идут в линейном порядке, писатель отдает данные группе рабочих, а
читатель принимает данные от группы работников (их количество зависит от числа потоков)
 -----------------------------------------------
 |                       manager               |
 -----------------------------------------------
  |            |                               |
---------     -------------              ---------        
| reader| <-> | Executer 1 | <-> ... <-> | writer|
---------      ------------              --------- 